use crate::ast::*;

grammar;

Num: f64 = r"[+-]?\d+(\.\d)?" => <>.parse::<f64>().unwrap();
Ident: String = r"[a-zA-z][\w']*\??" => String::from(<>);
Tuple: Vec<Expr> = {
    <t:Tuple> "," <e:Expr> => {
        let mut t = t;
        t.push(e);
        t
    },
    Expr => vec![<>],
};

pub Expr: Expr = {
    <l:Expr> "+" <r:ExprLevel1> => Expr::Comp(Operator::Add, Box::new(l), Box::new(r)),
    <l:Expr> "-" <r:ExprLevel1> => Expr::Comp(Operator::Sub, Box::new(l), Box::new(r)),
    ExprLevel1,
}

ExprLevel1: Expr = {
    <l:ExprLevel1> "*" <r:Value> => Expr::Comp(Operator::Mul, Box::new(l), Box::new(r)),
    <l:ExprLevel1> "/" <r:Value> => Expr::Comp(Operator::Div, Box::new(l), Box::new(r)),
    <l:ExprLevel1> "%" <r:Value> => Expr::Comp(Operator::Mod, Box::new(l), Box::new(r)),
    <l:ExprLevel1> "^" <r:Value> => Expr::Comp(Operator::Pow, Box::new(l), Box::new(r)),
    Value,
}

Value: Expr = {
    Num => Expr::Value(Value::Numeric(<>)),
    Ident => Expr::Ref(<>),
    "(" <Expr> ")",
    "(" <t:Tuple> "," <e:Expr> ")" => {
        let mut t = t;
        t.push(e);
        Expr::Value(Value::Tuple(t))
    },
    <i:Ident> "(" <t:Tuple> ")" => {
        Expr::Func(i, t)
    },
    <i:Ident> "(" ")" => {
        Expr::Func(i, vec![])
    },
};
