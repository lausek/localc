use crate::ast::*;

grammar;

Tier<Op,NextTier>: Expr = {
    <lhs:Tier<Op,NextTier>> <op:Op> <rhs:NextTier> => Expr::Comp(op, Box::new(lhs), Box::new(rhs)),
	NextTier
};

Log: LogType = {
	"true" => true,
	"false" => false,
};
Num: NumType = r"[+-]?\d+(\.\d)?" => <>.parse::<NumType>().unwrap();
Ident: String = r"[a-zA-z][\w']*\??" => String::from(<>);
Tuple: Vec<Expr> = {
    <t:Tuple> "," <e:Expr> => {
        let mut t = t;
        t.push(e);
        t
    },
    Expr => vec![<>],
};

Value: Expr = {
    Log => Expr::Value(Value::Logical(<>)),
    Num => Expr::Value(Value::Numeric(<>)),
    Ident => Expr::Ref(<>),
    "(" <Expr> ")",
    "(" <t:Tuple> "," <e:Expr> ")" => {
        let mut t = t;
        t.push(e);
        Expr::Value(Value::Tuple(t))
    },
    <i:Ident> "(" <t:Tuple> ")" => Expr::Func(i, t),
    <i:Ident> "(" ")" => Expr::Func(i, vec![]),
};

SumOps: Operator = {
	"+" => Operator::Add,
	"-" => Operator::Sub,
};

FactorOps: Operator = {
	"*" => Operator::Mul,
	"/" => Operator::Div,
	"%" => Operator::Rem,
	"^" => Operator::Pow,
};

VmOps: Operator = {
	"=" => Operator::Store,
};

OrOps: Operator = {
	"||" => Operator::Or,
};

AndOps: Operator = {
	"&&" => Operator::And,
};

CompareOps: Operator = {
    "==" => Operator::Eq,
    "!=" => Operator::Ne,
    ">=" => Operator::Ge,
    "<=" => Operator::Le,
    ">" => Operator::Gt,
    "<" => Operator::Lt,
};

Computations = Tier<SumOps, Tier<FactorOps, Value>>;
Compares = Tier<CompareOps, Computations>;
Logic = Tier<OrOps, Tier<AndOps, Compares>>;
pub Expr = Tier<VmOps, Logic>;
